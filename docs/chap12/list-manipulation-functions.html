<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="copyright" content="(C) Copyright 2019"><meta name="DC.rights.owner" content="(C) Copyright 2019"><meta name="DC.type" content="topic"><meta name="DC.relation" scheme="URI" content="../chap12/list-processing.html"><meta name="DC.format" content="HTML5"><meta name="DC.identifier" content="list-manipulation-functions列表处理函数"><link rel="stylesheet" type="text/css" href="../commonltr.css"><title>List-Manipulation Functions（列表处理函数）</title></head><body id="list-manipulation-functions列表处理函数"><main role="main"><article role="article" aria-labelledby="ariaid-title1"><h1 class="title topictitle1" id="ariaid-title1">List-Manipulation Functions（列表处理函数）</h1><div class="body"><p class="p">With that background out of the way, you're ready to look at the
library of functions Common Lisp provides for manipulating lists.</p><p class="p">有了前面这些背景知识，现在就可以开始学习 Common Lisp
为处理列表而提供的函数库了。</p><p class="p">You've already seen the basic functions for getting at the elements of
a list: <strong class="ph b">FIRST</strong> and <strong class="ph b">REST</strong>. Although you can get at any element of a list
by combining enough calls to <strong class="ph b">REST</strong> (to move down the list) with a <strong class="ph b">FIRST</strong>
(to extract the element), that can be a bit tedious. So Common Lisp
provides functions named for the other ordinals from <strong class="ph b">SECOND</strong> to <strong class="ph b">TENTH</strong>
that return the appropriate element. More generally, the function <strong class="ph b">NTH</strong>
takes two arguments, an index and a list, and returns the nth
(zero-based) element of the list. Similarly, <strong class="ph b">NTHCDR</strong> takes an index and
a list and returns the result of calling <strong class="ph b">CDR</strong> n times. (Thus,
<code class="ph codeph">(nthcdr 0 ...)</code> simply returns the original list, and <code class="ph codeph">(nthcdr 1 ...)</code> is
equivalent to <strong class="ph b">REST</strong>.) Note, however, that none of these functions is
any more efficient, in terms of work done by the computer, than the
equivalent combinations of <strong class="ph b">FIRST</strong>s and <strong class="ph b">REST</strong>s--there's no way to get to
the nth element of a list without following n <strong class="ph b">CDR</strong> references.</p><p class="p">前面已经介绍了获取列表中元素的基本函数：<strong class="ph b">FIRST</strong> 和
<strong class="ph b">REST</strong>。尽管可以通过将足够多的 <strong class="ph b">REST</strong> 调用（用于深入列表）和一个
<strong class="ph b">FIRST</strong> 调用（用于抽取元素）组合起来以获得一个列表中的任意元素，但这样可能有点冗长。因此，Common
Lisp 提供了以从 <strong class="ph b">SECOND</strong> 到 <strong class="ph b">TENTH</strong>
的由其他序数命名的函数来返回相应的元素。而函数 <strong class="ph b">NTH</strong>
则更为普遍，它接受两个参数，一个索引和一个列表，并返回列表中第 n
个（从 0 开始）元素。类似地，<strong class="ph b">NTHCDR</strong> 接受一个索引和一个列表并返回 n
次调用 <strong class="ph b">CDR</strong> 的结果。
（这样，<code class="ph codeph">(nthcdr 0 ...)</code> 简单地返回最初的列表，而 <code class="ph codeph">(nthcdr 1 ...)</code>
等价于 <strong class="ph b">REST</strong>。）但要注意的是，就计算机完成的工作而言，这些函数都不会比等价的
<strong class="ph b">FIRST</strong> 和 <strong class="ph b">REST</strong>
组合更高效，因位无法在没有跟随 n 个 <strong class="ph b">CDR</strong>
引用的情况下得到一个列表的第 n 个元素。</p><p class="p">The 28 composite <strong class="ph b">CAR</strong>/<strong class="ph b">CDR</strong> functions are another family of functions you
may see used from time to time. Each function is named by placing a
sequence of up to four <code class="ph codeph">A</code>s and <code class="ph codeph">D</code>s between a <code class="ph codeph">C</code> and <code class="ph codeph">R</code>, with each A
representing a call to <strong class="ph b">CAR</strong> and each <code class="ph codeph">D</code> a call to <strong class="ph b">CDR</strong>. Thus:</p><p class="p">另一个不时会用到的函数家族是 28 个复合 <strong class="ph b">CAR</strong>/<strong class="ph b">CDR</strong> 函数。每个函数都是通过将由最多四个 <code class="ph codeph">A</code> 和 <code class="ph codeph">D</code>
组成的序列放在 <code class="ph codeph">C</code> 和 <code class="ph codeph">R</code> 之间来命名的，其中每个 <code class="ph codeph">A</code> 代表对 <strong class="ph b">CAR</strong>
的调用而每个 <code class="ph codeph">D</code> 代表对 <strong class="ph b">CDR</strong> 的调用。因此我们可以得到：</p><pre class="pre codeblock lisp"><code>(caar list) === (car (car list))
(cadr list) === (car (cdr list))
(cadadr list) === (car (cdr (car (cdr list))))</code></pre><p class="p">Note, however, that many of these functions make sense only when
applied to lists that contain other lists. For instance, <strong class="ph b">CAAR</strong> extracts
the <strong class="ph b">CAR</strong> of the <strong class="ph b">CAR</strong> of the list it's given; thus, the list it's passed
must contain another list as its first element. In other words, these
are really functions on trees rather than lists:</p><p class="p">但要注意，这其中许多函数仅当应用于含有其他列表的列表时才有意义。例如，<strong class="ph b">CAAR</strong>
抽取出给定列表的 <strong class="ph b">CAR</strong> 的
<strong class="ph b">CAR</strong>，因此传递给它的列表必须含有另一个列表，并将该列表用作其第一个元素。换句话说，这些函数其实是用于树而不是列表的：</p><pre class="pre codeblock lisp"><code>(caar (list 1 2 3))                  ==&gt; error
(caar (list (list 1 2) 3))           ==&gt; 1
(cadr (list (list 1 2) (list 3 4)))  ==&gt; (3 4)
(caadr (list (list 1 2) (list 3 4))) ==&gt; 3</code></pre><p class="p">These functions aren't used as often now as in the old days. And even
the most die-hard old-school Lisp hackers tend to avoid the longer
combinations. However, they're used quite a bit in older Lisp code, so
it's worth at least understanding how they work.</p><p class="p">现在这些函数不像以前那样常用了。并且即便是最顽固的守旧 Lisp
黑客也倾向于避免使用过长的组合。尽管如此，它们还是被用在很多古老的 Lisp
代码上，因此至少应当去理解它们的工作方式。</p><p class="p">The <strong class="ph b">FIRST-TENTH</strong> and <strong class="ph b">CAR</strong>, <strong class="ph b">CADR</strong>, and so on, functions can also be used
as <strong class="ph b">SETF</strong>able places if you're using lists nonfunctionally.</p><p class="p">如果你正在非函数式地使用列表，这些 <strong class="ph b">FIRST-TENTH</strong> 和 <strong class="ph b">CAR</strong>、<strong class="ph b">CADR</strong>
等函数也可被用作 <strong class="ph b">SETF</strong> 的位置。</p><p class="p">Table 12-1 summarizes some other list functions that I won't cover in detail.</p><p class="p">表 12-1 总结了其他一些我不会详细介绍的列表函数。</p><blockquote class="lq"><p class="p">Table 12-1. Other List Functions</p></blockquote><table class="table"><caption></caption><colgroup><col><col></colgroup><thead class="thead"><tr class="row"><th class="entry align-left" id="list-manipulation-functions列表处理函数__entry__1">Function</th><th class="entry align-left" id="list-manipulation-functions列表处理函数__entry__2">Description</th></tr></thead><tbody class="tbody"><tr class="row"><td class="entry align-left" headers="list-manipulation-functions列表处理函数__entry__1 "><strong class="ph b">LAST</strong></td><td class="entry align-left" headers="list-manipulation-functions列表处理函数__entry__2 ">Returns the last cons cell in a list. With an integer, argument returns the last n cons cells.</td></tr><tr class="row"><td class="entry align-left" headers="list-manipulation-functions列表处理函数__entry__1 "><strong class="ph b">BUTLAST</strong></td><td class="entry align-left" headers="list-manipulation-functions列表处理函数__entry__2 ">Returns a copy of the list, excluding the last cons cell. With an integer argument, excludes the last n cells.</td></tr><tr class="row"><td class="entry align-left" headers="list-manipulation-functions列表处理函数__entry__1 "><strong class="ph b">NBUTLAST</strong></td><td class="entry align-left" headers="list-manipulation-functions列表处理函数__entry__2 ">The recycling version of <strong class="ph b">BUTLAST</strong>; may modify and return the argument list but has no reliable side effects.</td></tr><tr class="row"><td class="entry align-left" headers="list-manipulation-functions列表处理函数__entry__1 "><strong class="ph b">LDIFF</strong></td><td class="entry align-left" headers="list-manipulation-functions列表处理函数__entry__2 ">Returns a copy of a list up to a given cons cell.</td></tr><tr class="row"><td class="entry align-left" headers="list-manipulation-functions列表处理函数__entry__1 "><strong class="ph b">TAILP</strong></td><td class="entry align-left" headers="list-manipulation-functions列表处理函数__entry__2 ">Returns true if a given object is a cons cell that's part of the structure of a list.</td></tr><tr class="row"><td class="entry align-left" headers="list-manipulation-functions列表处理函数__entry__1 "><code class="ph codeph">LIST*</code></td><td class="entry align-left" headers="list-manipulation-functions列表处理函数__entry__2 ">Builds a list to hold all but the last of its arguments and then makes the last argument the CDR of the last cell in the list. In other words, a cross between <strong class="ph b">LIST</strong> and <strong class="ph b">APPEND</strong>.</td></tr><tr class="row"><td class="entry align-left" headers="list-manipulation-functions列表处理函数__entry__1 "><strong class="ph b">MAKE-LIST</strong></td><td class="entry align-left" headers="list-manipulation-functions列表处理函数__entry__2 ">Builds an n item list. The initial elements of the list are <strong class="ph b">NIL</strong> or the value specified with the :initial-element keyword argument.</td></tr><tr class="row"><td class="entry align-left" headers="list-manipulation-functions列表处理函数__entry__1 "><strong class="ph b">REVAPPEND</strong></td><td class="entry align-left" headers="list-manipulation-functions列表处理函数__entry__2 ">Combination of <strong class="ph b">REVERSE</strong> and <strong class="ph b">APPEND</strong>; reverses first argument as with <strong class="ph b">REVERSE</strong> and then appends the second argument.</td></tr><tr class="row"><td class="entry align-left" headers="list-manipulation-functions列表处理函数__entry__1 "><strong class="ph b">NRECONC</strong></td><td class="entry align-left" headers="list-manipulation-functions列表处理函数__entry__2 ">Recycling version of <strong class="ph b">REVAPPEND</strong>; reverses first argument as if by <strong class="ph b">NREVERSE</strong> and then appends the second argument. No reliable side effects.</td></tr><tr class="row"><td class="entry align-left" headers="list-manipulation-functions列表处理函数__entry__1 "><strong class="ph b">CONSP</strong></td><td class="entry align-left" headers="list-manipulation-functions列表处理函数__entry__2 ">Predicate to test whether an object is a cons cell.</td></tr><tr class="row"><td class="entry align-left" headers="list-manipulation-functions列表处理函数__entry__1 "><strong class="ph b">ATOM</strong></td><td class="entry align-left" headers="list-manipulation-functions列表处理函数__entry__2 ">Predicate to test whether an object is not a cons cell.</td></tr><tr class="row"><td class="entry align-left" headers="list-manipulation-functions列表处理函数__entry__1 "><strong class="ph b">LISTP</strong></td><td class="entry align-left" headers="list-manipulation-functions列表处理函数__entry__2 ">Predicate to test whether an object is either a cons cell or <strong class="ph b">NIL</strong>.</td></tr><tr class="row"><td class="entry align-left" headers="list-manipulation-functions列表处理函数__entry__1 "><strong class="ph b">NULL</strong></td><td class="entry align-left" headers="list-manipulation-functions列表处理函数__entry__2 ">Predicate to test whether an object is <strong class="ph b">NIL</strong>. Functionally equivalent to <strong class="ph b">NOT</strong> but stylistically preferable when testing for an empty list as opposed to boolean false.</td></tr></tbody></table></div><nav role="navigation" class="related-links"><div class="familylinks"><div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="../chap12/list-processing.html">They Called It LISP for a Reason: List Processing（LISP 名字的由来：列表处理）</a></div></div></nav></article></main></body></html>