<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="copyright" content="(C) Copyright 2019"><meta name="DC.rights.owner" content="(C) Copyright 2019"><meta name="DC.type" content="topic"><meta name="DC.relation" scheme="URI" content="../chap07/macros-standard-control-constructs.html"><meta name="DC.format" content="HTML5"><meta name="DC.identifier" content="dolist-and-dotimesdolist-和-dotimes-宏"><link rel="stylesheet" type="text/css" href="../commonltr.css"><title>DOLIST and DOTIMES（DOLIST 和 DOTIMES 宏）</title></head><body id="dolist-and-dotimesdolist-和-dotimes-宏"><main role="main"><article role="article" aria-labelledby="ariaid-title1"><h1 class="title topictitle1" id="ariaid-title1">DOLIST and DOTIMES（DOLIST 和 DOTIMES 宏）</h1><div class="body"><p class="p">I'll start with the easy-to-use <strong class="ph b">DOLIST</strong> and <strong class="ph b">DOTIMES</strong> macros.</p><p class="p">先从易于使用的 <strong class="ph b">DOLIST</strong> 和 <strong class="ph b">DOTIMES</strong> 宏开始。</p><p class="p"><strong class="ph b">DOLIST</strong> loops across the items of a list, executing the loop body with
a variable holding the successive items of the list. This is the
basic skeleton (leaving out some of the more esoteric options):</p><p class="p"><strong class="ph b">DOLIST</strong>
在一个列表的元素上循环操作，使用一个依次持有列表中所有后继元素的变量来执行循环体。下面是其基本形式（去掉了一些比较难懂的选项）：</p><pre class="pre codeblock lisp"><code>(dolist (var list-form)
  body-form*)</code></pre><p class="p">When the loop starts, the <code class="ph codeph">list-form</code> is evaluated once to produce a
list. Then the body of the loop is evaluated once for each item in
the list with the variable <code class="ph codeph">var</code> holding the value of the item. For
instance:</p><p class="p">当循环开始时，<code class="ph codeph">list-form</code>
被求值一次以产生一个列表。然后循环体在列表的每一项上求值一次，同时用变量
<code class="ph codeph">var</code> 保存当前项的值。例如：</p><pre class="pre codeblock lisp"><code>CL-USER&gt; (dolist (x '(1 2 3)) (print x))
1
2
3
NIL</code></pre><p class="p">Used this way, the <strong class="ph b">DOLIST</strong> form as a whole evaluates to <strong class="ph b">NIL</strong>.</p><p class="p">在这种方式下，<strong class="ph b">DOLIST</strong> 这种形式本身求值为 <strong class="ph b">NIL</strong>。</p><p class="p">If you want to break out of a <strong class="ph b">DOLIST</strong> loop before the end of the list,
you can use <strong class="ph b">RETURN</strong>.</p><p class="p">如果想在列表结束之前中断一个 <strong class="ph b">DOLIST</strong> 循环，则可以使用 <strong class="ph b">RETURN</strong>。</p><pre class="pre codeblock lisp"><code>CL-USER&gt; (dolist (x '(1 2 3)) (print x) (if (evenp x) (return)))
1
2
NIL</code></pre><p class="p"><strong class="ph b">DOTIMES</strong> is the high-level looping construct for counting loops. The
basic template is much the same as <strong class="ph b">DOLIST</strong>'s.</p><p class="p"><strong class="ph b">DOTIMES</strong> 是用于循环计数的高级循环构造。其基本模板和 <strong class="ph b">DOLIST</strong> 非常相似。</p><pre class="pre codeblock lisp"><code>(dotimes (var count-form)
  body-form*)</code></pre><p class="p">The <code class="ph codeph">count-form</code> must evaluate to an integer. Each time through the loop
<code class="ph codeph">var</code> holds successive integers from 0 to one less than that number. For
instance:</p><p class="p">其中的 <code class="ph codeph">count-form</code> 必须要能求值为一个整数。通过每次循环，<code class="ph codeph">var</code>
所持有的整数依次为从 0 到比那个数小 1 的每一个后继整数。例如：</p><pre class="pre codeblock lisp"><code>CL-USER&gt; (dotimes (i 4) (print i))
0
1
2
3
NIL</code></pre><p class="p">As with <strong class="ph b">DOLIST</strong>, you can use <strong class="ph b">RETURN</strong> to break out of the loop early.</p><p class="p">和 <strong class="ph b">DOLIST</strong> 一样，也可以使用 <strong class="ph b">RETURN</strong> 来提前中断循环。</p><p class="p">Because the body of both <strong class="ph b">DOLIST</strong> and <strong class="ph b">DOTIMES</strong> loops can contain any kind
of expressions, you can also nest loops. For example, to print out the
times tables from 1 × 1 = 1 to 20 × 20 = 400, you can write this pair
of nested <strong class="ph b">DOTIMES</strong> loops:</p><p class="p">由于 <strong class="ph b">DOLIST</strong> 和 <strong class="ph b">DOTIMES</strong>
的循环体中可以包含任何类型的表达式，因此也可以使用嵌套循环。例如，为了打印出从
1 × 1 = 1 到 20 × 20 = 400 的乘法表，可以写出下面这对嵌套的
<strong class="ph b">DOTIMES</strong> 循环：</p><pre class="pre codeblock lisp"><code>(dotimes (x 20)
  (dotimes (y 20)
    (format t "~3d " (* (1+ x) (1+ y))))
  (format t "~%"))</code></pre></div><nav role="navigation" class="related-links"><div class="familylinks"><div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="../chap07/macros-standard-control-constructs.html">Macros: Standard Control Constructs（宏：标准控制结构）</a></div></div></nav></article></main></body></html>