<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="copyright" content="(C) Copyright 2019"><meta name="DC.rights.owner" content="(C) Copyright 2019"><meta name="DC.type" content="topic"><meta name="DC.relation" scheme="URI" content="../chap11/collections.html"><meta name="DC.format" content="HTML5"><meta name="DC.identifier" content="sequence-predicates序列谓词"><link rel="stylesheet" type="text/css" href="../commonltr.css"><title>Sequence Predicates（序列谓词）</title></head><body id="sequence-predicates序列谓词"><main role="main"><article role="article" aria-labelledby="ariaid-title1"><h1 class="title topictitle1" id="ariaid-title1">Sequence Predicates（序列谓词）</h1><div class="body"><p class="p">Four other handy functions are <strong class="ph b">EVERY</strong>, <strong class="ph b">SOME</strong>, <strong class="ph b">NOTANY</strong>, and <strong class="ph b">NOTEVERY</strong>,
which iterate over sequences testing a boolean predicate. The first
argument to all these functions is the predicate, and the remaining
arguments are sequences. The predicate should take as many arguments
as the number of sequences passed. The elements of the sequences are
passed to the predicate--one element from each sequence--until one of
the sequences runs out of elements or the overall termination test is
met: <strong class="ph b">EVERY</strong> terminates, returning false, as soon as the predicate
fails. If the predicate is always satisfied, it returns true. <strong class="ph b">SOME</strong>
returns the first non-<strong class="ph b">NIL</strong> value returned by the predicate or returns
false if the predicate is never satisfied. <strong class="ph b">NOTANY</strong> returns false as
soon as the predicate is satisfied or true if it never is. And
<strong class="ph b">NOTEVERY</strong> returns true as soon as the predicate fails or false if the
predicate is always satisfied. Here are some examples of testing just
one sequence:</p><p class="p">另外四个常见的函数是 <strong class="ph b">EVERY</strong>、<strong class="ph b">SOME</strong>、<strong class="ph b">NOTANY</strong> 和
<strong class="ph b">NOTEVERY</strong>，它们在序列上迭代并测试一个布尔谓词。所有这些函数的第一参数是一个谓词，其余的参数都是序列。这个谓词应当接受与所传递序列相同数量的参数。序列的元素被传递给该谓词，每个序列中各取出一个元素，直到某个序列用完所有的元素或是整体终止测试条件被满足：<strong class="ph b">EVERY</strong>
在谓词失败时返回假。如果谓词总被满足，它返回真。<strong class="ph b">SOME</strong>
返回由谓词所返回的第一个非NIL值，或者在谓词永远得不到满足时返回假。<strong class="ph b">NOTANY</strong>
将在谓词满足时返回假，或者在从未满足时返回真。而
<strong class="ph b">NOTEVERY</strong>
在谓词失败时返回真，或是在谓词总是满足时返回假。下面是一些仅测试在一个序列上的例子：</p><pre class="pre codeblock lisp"><code>(every #'evenp #(1 2 3 4 5))    ==&gt; NIL
(some #'evenp #(1 2 3 4 5))     ==&gt; T
(notany #'evenp #(1 2 3 4 5))   ==&gt; NIL
(notevery #'evenp #(1 2 3 4 5)) ==&gt; T</code></pre><p class="p">These calls compare elements of two sequences pairwise:</p><p class="p">下面的调用比较成对的两个序列中的元素：</p><pre class="pre codeblock lisp"><code>(every #'&gt; #(1 2 3 4) #(5 4 3 2))    ==&gt; NIL
(some #'&gt; #(1 2 3 4) #(5 4 3 2))     ==&gt; T
(notany #'&gt; #(1 2 3 4) #(5 4 3 2))   ==&gt; NIL
(notevery #'&gt; #(1 2 3 4) #(5 4 3 2)) ==&gt; T</code></pre></div><nav role="navigation" class="related-links"><div class="familylinks"><div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="../chap11/collections.html">Collections（集合）</a></div></div></nav></article></main></body></html>