<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="copyright" content="(C) Copyright 2019"><meta name="DC.rights.owner" content="(C) Copyright 2019"><meta name="DC.type" content="topic"><meta name="DC.relation" scheme="URI" content="../chap14/files-and-file-io.html"><meta name="DC.format" content="HTML5"><meta name="DC.identifier" content="file-output文件输出"><link rel="stylesheet" type="text/css" href="../commonltr.css"><title>File Output（文件输出）</title></head><body id="file-output文件输出"><main role="main"><article role="article" aria-labelledby="ariaid-title1"><h1 class="title topictitle1" id="ariaid-title1">File Output（文件输出）</h1><div class="body"><p class="p">To write data to a file, you need an output stream, which you obtain
by calling <strong class="ph b">OPEN</strong> with a <code class="ph codeph">:direction</code> keyword argument of <code class="ph codeph">:output</code>. When
opening a file for output, <strong class="ph b">OPEN</strong> assumes the file shouldn't already
exist and will signal an error if it does. However, you can change
that behavior with the <code class="ph codeph">:if-exists</code> keyword argument. Passing the value
<code class="ph codeph">:supersede</code> tells <strong class="ph b">OPEN</strong> to replace the existing file. Passing <code class="ph codeph">:append</code>
causes <strong class="ph b">OPEN</strong> to open the existing file such that new data will be
written at the end of the file, while <code class="ph codeph">:overwrite</code> returns a stream that
will overwrite existing data starting from the beginning of the
file. And passing <strong class="ph b">NIL</strong> will cause <strong class="ph b">OPEN</strong> to return <strong class="ph b">NIL</strong> instead of a
stream if the file already exists. A typical use of <strong class="ph b">OPEN</strong> for output
looks like this:</p><p class="p">为了向一个文件中写数据，你需要一个输出流。你可以通过在调用 <strong class="ph b">OPEN</strong>
时使用一个值为 <code class="ph codeph">:output</code> 的 <code class="ph codeph">:direction</code>
关键字参数来获取它。当你打开一个用于输出的文件时，<strong class="ph b">OPEN</strong>
会假设该文件不该存在并会在文件存在时报错。但你可以使用 <code class="ph codeph">:if-exists</code>
关键字参数来改变该行为。传递值 <code class="ph codeph">:supersede</code> 可以告诉 <strong class="ph b">OPEN</strong>
来替换已有文件。传递 <code class="ph codeph">:append</code> 将导致 <strong class="ph b">OPEN</strong>
打开已有的文件并保证新数据被写到文件结尾处，而 <code class="ph codeph">:overwrite</code>
返回一个从文件开始处开始的流从而覆盖已有数据。而传递 <strong class="ph b">NIL</strong>
将导致 <strong class="ph b">OPEN</strong> 在文件已存在时返回 <strong class="ph b">NIL</strong>
而不是流。一个典型的使用 <strong class="ph b">OPEN</strong> 来输出的例子如下所示：</p><pre class="pre codeblock lisp"><code>(open "/some/file/name.txt" :direction :output :if-exists :supersede)</code></pre><p class="p">Common Lisp also provides several functions for writing data:
<strong class="ph b">WRITE-CHAR</strong> writes a single character to the stream. <strong class="ph b">WRITE-LINE</strong> writes
a string followed by a newline, which will be output as the
appropriate end-of-line character or characters for the
platform. Another function, <strong class="ph b">WRITE-STRING</strong>, writes a string without
adding any end-of-line characters. Two different functions can print
just a newline: <strong class="ph b">TERPRI</strong>--short for "terminate print"--unconditionally
prints a newline character, and <strong class="ph b">FRESH-LINE</strong> prints a newline character
unless the stream is at the beginning of a line. <strong class="ph b">FRESH-LINE</strong> is handy
when you want to avoid spurious blank lines in textual output
generated by different functions called in sequence. For example,
suppose you have one function that generates output that should always
be followed by a line break and another that should start on a new
line. But assume that if the functions are called one after the other,
you don't want a blank line between the two bits of output. If you use
<strong class="ph b">FRESH-LINE</strong> at the beginning of the second function, its output will
always start on a new line, but if it's called right after the first,
it won't emit an extra line break.</p><p class="p">Common Lisp 也提供了几个用于写数据的函数：<strong class="ph b">WRITE-CHAR</strong>
会向流中写入一个单一字符；<strong class="ph b">WRITE-LINE</strong>
写一个字符串并紧跟一个换行，其将被输出成用于当前平台的适当行结束字符或字符序列。另一个函数
<strong class="ph b">WRITE-STRING</strong> 写一个字符串而不会添加任何行结束符。有两个不同的函数
可以只打印一个换行：<strong class="ph b">TERPRI</strong>
是 “终止打印（terminate print）”
的简称，即无条件地打印一个换行字符；<strong class="ph b">FRESH-LINE</strong>
打印一个换行字符，除非该流已经在一行的开始处。在想要避免由按顺序调用的不同函数所生成的文本输出中的额外换行时，<strong class="ph b">FRESH-LINE</strong>
很有用。例如，假设一个函数在其生成输出时总是带有一个换行，而另一个函数应当每次从一个新行开始输出。但假设这两个函数被依次调用，而你又不希望在两个输出操作之间产生一个空行，那么如果你在第二个函数开始处使用
<strong class="ph b">FRESH-LINE</strong>，那么它的输出将总是从一个新行开始。但如果它刚好在前一个函数之后调用，则它将不会产生一个额外换行。</p><p class="p">Several functions output Lisp data as s-expressions: <strong class="ph b">PRINT</strong> prints an
s-expression preceded by an end-of-line and followed by a space. <strong class="ph b">PRIN1</strong>
prints just the s-expression. And the function <strong class="ph b">PPRINT</strong> prints
s-expressions like <strong class="ph b">PRINT</strong> and <strong class="ph b">PRIN1</strong> but using the "pretty printer,"
which tries to print its output in an aesthetically pleasing way.</p><p class="p">有几个函数会将 Lisp 数据输出成 S-表达式：<strong class="ph b">PRINT</strong>
打印一个 S-表达式，前缀一个换行及一个空格；<strong class="ph b">PRIN1</strong> 只打印 S-表达式；而函数
<strong class="ph b">PPRINT</strong> 会像 <strong class="ph b">PRINT</strong> 和 <strong class="ph b">PRIN1</strong> 那样打印
S-表达式，但使用的是美化打印器（pretty printer），它试图将输出打印得赏心悦目。</p><p class="p">However, not all objects can be printed in a form that <strong class="ph b">READ</strong> will
understand. The variable <code class="ph codeph">*PRINT-READABLY*</code> controls what happens if you
try to print such an object with <strong class="ph b">PRINT</strong>, <strong class="ph b">PRIN1</strong>, or <strong class="ph b">PPRINT</strong>. When it's
<strong class="ph b">NIL</strong>, these functions will print the object in a special syntax that's
guaranteed to cause <strong class="ph b">READ</strong> to signal an error if it tries to read it;
otherwise they will signal an error rather than print the object.</p><p class="p">但并非所有对象都能以一种 <strong class="ph b">READ</strong> 可理解的形式打印出来。当试图使用
<strong class="ph b">PRINT</strong>、<strong class="ph b">PRIN1</strong> 或 <strong class="ph b">PPRINT</strong> 来打印这样一种对象时，变量
<code class="ph codeph">*PRINT-READABLY*</code> 将会予以控制。当它是 <strong class="ph b">NIL</strong>
时，这些函数将以一种导致 <strong class="ph b">READ</strong>
在试图读取时肯定会报错的特殊语法来打印该对象；否则它们将直接报错而不打印该对象。</p><p class="p">Another function, <strong class="ph b">PRINC</strong>, also prints Lisp objects, but in a way
designed for human consumption. For instance, <strong class="ph b">PRINC</strong> prints strings
without quotation marks. You can generate more elaborate text output
with the incredibly flexible if somewhat arcane <strong class="ph b">FORMAT</strong> function. I'll
discuss some of the more important details of <strong class="ph b">FORMAT</strong>, which
essentially defines a mini-language for emitting formatted output, in
Chapter 18.</p><p class="p">另一个函数 <strong class="ph b">PRINC</strong> 也会打印 Lisp
对象，但其工作方式却很适合人们使用。例如，<strong class="ph b">PRINC</strong>
在打印字符串时不带有引号。你可以使用极其灵活但有时略显神秘的
<strong class="ph b">FORMAT</strong> 函数来生成更加复杂的文本输出。我将在第 18
章里讨论一些关于 <strong class="ph b">FORMAT</strong>
的更重要的细节，它从本质上定义了一种用于产生格式化输出的微型语言。</p><p class="p">To write binary data to a file, you have to <strong class="ph b">OPEN</strong> the file with the
same <code class="ph codeph">:element-type</code> argument as you did to read it: <code class="ph codeph">'(unsigned-byte 8)</code>.
You can then write individual bytes to the stream with WRITE-BYTE.</p><p class="p">为了向一个文件中写入二进制数据，你需要在使用 <strong class="ph b">OPEN</strong>
打开文件时带有与读取该文件时相同的 <code class="ph codeph">:element-type</code> 实参，其值为
<code class="ph codeph">'(unsigned-byte 8)</code>，然后就可以使用 <strong class="ph b">WRITE-BYTE</strong> 向流中写入单独的字节。</p><p class="p">The bulk output function <strong class="ph b">WRITE-SEQUENCE</strong> accepts both binary and
character streams as long as all the elements of the sequence are of
an appropriate type for the stream, either characters or bytes. As
with <strong class="ph b">READ-SEQUENCE</strong>, this function is likely to be quite a bit more
efficient than writing the elements of the sequence one at a time.</p><p class="p">批量输出函数 <strong class="ph b">WRITE-SEQUENCE</strong>
可同时接受二进制和字符流，只要序列中的所有元素都是用于该流的适当类型即可，无论其是字符还是字节。和
<strong class="ph b">READ-SEQUENCE</strong> 一样，该函数会比每次输出一个序列元素更为高效。</p></div><nav role="navigation" class="related-links"><div class="familylinks"><div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="../chap14/files-and-file-io.html">Files and File I/O（文件和文件 I/O）</a></div></div></nav></article></main></body></html>